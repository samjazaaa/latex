\documentclass[11pt, paper=a4, twocolumn]{scrartcl}

\usepackage[ngerman]{babel}
\usepackage[utf8]{inputenc}

\usepackage[T1]{fontenc}
\usepackage{mathpazo}

\usepackage{geometry}

\geometry{a4paper, top=20mm, left=15mm, right=15mm, bottom=20mm,
headsep=5mm, footskip=12mm}


\pagenumbering{gobble}

\title{\vspace{-1.25cm}SEH summary\vspace{-0.25cm}}
\date{\vspace{-5ex}}

\newcommand*{\Z}{\mathbb{Z}}

\begin{document}
	\maketitle


	\section{Introduction}
		\begin{itemize}
			\item Dependable systems
				\begin{itemize}
					\item Attributes / Goals (what)
						\begin{itemize}
							\item Confidentiality (no unauthorized disclosure)
							\item Integrity (absence of improper states)
							\item Availability (possibility in nines)
							\item Reliability (mean time to failure)
							\item Safety (consequences for user)
							\item Maintainability
						\end{itemize}
					\item Means (how)
						\begin{itemize}
							\item Fault Prevention
							\item Fault Tolerance
							\item Fault Removal
							\item Fault Forecasting
						\end{itemize}
					\item Threats (against)
						\begin{itemize}
							\item Faults
							\item Errors (state)
							\item Failures (interface behavior)
						\end{itemize}
				\end{itemize}
			\item Risk management
			\item Safety (protect people) vs. Security (CIA)
			\item Authentication (integrity of source, matching identity with entity)
			\item Non-reputability (prevent denial)
			\item Anonymity
		\end{itemize}


	\section{Attack Scenarios in General}
		\begin{itemize}
			\item Types of flaws (security faults)
				\begin{itemize}
					\item intentional malicious (trojan)
					\item intentional non-malicious (debug interface)
					\item inadvertent (software bug)
				\end{itemize}
			\item Attacker classes
				\begin{itemize}
					\item Clever outsider (low resources)
					\item Knowledgeable Insiders (medium resources, big money)
					\item Funded Organizations (high, mafia, also non-technical)
				\end{itemize}
			\item Attack categories
				\begin{itemize}
					\item inv. log.: code injection
					\item inv. phys.: damaging, microprobing
					\item non. log.: phish, crypto, copying
					\item non. phys.: eavesdropping, side-channel
				\end{itemize}
			\item Attacks and Countermeasures on different hw / sw abstraction levels
			\item Attack scenarios
				\begin{itemize}
					\item Malicious software / firmware update
					\item Malicious program installation
					\item Reverse engineering (implementation details, vulnerabilities, IP)
					\item Modifying integrated circuit (read memory by cutting jump signal and bus probing)
					\item Phishing (social)
					\item Forged authenticity (DNS / cert spoof, systems)
					\item Crypto attacks
					\item Eavesdropping (prevented by encryption)
					\item Side-channel attacks (timing, power, fault)
				\end{itemize}
		\end{itemize}

	\section{Attack Scenarios Cryptography}
		\begin{itemize}
			\item Cryptography (designing) vs. Cryptoanalysis (breaking) vs. Cryptology (both)
			\item Block ciphers vs. Stream ciphers
			\item Monoalphabetic substitution ciphers (bad because of probability)
			\item Vigen√®re (key repeatedly added to plain)
			\item One-Time Pad (same length as plain)
			\item symmetric vs. asymmetric methods
			\item DES
				\begin{itemize}
					\item 56 bit key, 64 bit block
					\item 16 Feistel rounds: expansion, substitution, permutation
					\item Brute forcable (Deep Crack, COPACOBANA: 65 billion key/sec) $\Rightarrow$ max 12 days
					\item Triple-DES (enc,dec,enc) $\Rightarrow$ 168 (eff:112) bit key
				\end{itemize}
			\item AES (Rijndael)
				\begin{itemize}
					\item 128 (10) / 192 (12) / 256 (14) bit keys (rounds)
					\item 128 bit block
					\item 256 byte S-Box
					\item Key Expansion, Initial Round, Rounds, Final Round
					\item Round (work on square state)
						\begin{itemize}
							\item SubByte (S-Box)
							\item ShiftRows (circular, increasing)
							\item MixColumn (polynom)
							\item AddRoundKey
						\end{itemize}
				\end{itemize}
			\item RSA
				\begin{itemize}
					\item factorizing as one way function
					\item Large primes $p$ and $q$
					\item $N_1 = p*q$, $N_2=(p-1)*(q-1)$
					\item $e$ such that $gcd(N_2,e) = 1$ and $0<e<N_2$
					\item $d$ such that $d*e\;mod\;N_2=1$
					\item Enc: $c\equiv m^e\;mod\;N_1$
					\item Dec: $m \equiv c^d\;mod\;N_1$
					\item DES 100 (sw) / 10000 (hw) times faster
					\item Used to encrypt session key for symmetric methods
				\end{itemize}
		\end{itemize}

	\section{Code Injection Attacks}
		\begin{itemize}
			\item Von Neumann concepts
				\begin{itemize}
					\item memory, control unit (control path), arithmetic and logic unit  (data path)
					\item Instruction fetch, decode, read operand, execute, write result
					\item Sequential execution vs. Pipelining
					\item Leon3 as example: 7 stages pipeline, MMU, seperate caches
				\end{itemize}
			\item Code Injection Attacks in general
				\begin{itemize}
					\item Insert routine (mostly embedded into input) and finding its address
					\item Manipulating program flow to execute it (overflows, return into libc, pointer)
				\end{itemize}
			\item Control Flow Graph
				\begin{itemize}
					\item Basic Block: sequence without jumps or branches
					\item Beginnings: first instruction, jump targets, instructions after jump / branch
					\item Control Flow Graph CFG(BB,T), where BB basic blocks and T transitions
				\end{itemize}
			\item Stack-based Buffer Overflows
				\begin{itemize}
					\item Return address first entry after function call, then base pointer
					\item Write (shell)code into buffer and overwrite return pointer
					\item Overwriting the framepointer also can do the job
				\end{itemize}
			\item Heap-based Buffer Overflows
				\begin{itemize}
					\item Unlink macro merges boarded segments
					\item next-Pointer can be overwritten with 'return - 3' and prev with beginning of code
					\item Unlinking will overwrite the return with the beginning of the code
				\end{itemize}
			\item Arc injection - ret2libc / ROP
				\begin{itemize}
					\item Inserting new control flow transpher
					\item Redirect return to libc function call (system)
					\item Returning to gadgets with returns (followed by their args)
					\item Gadgets are found in libraries and through miss-alignment
				\end{itemize}
			\item Pointer Subterfuge
				\begin{itemize}
					\item Function pointer clobbering: modify function pointer of virtual function
					\item Data pointer manipulation: arbitrary memory writes
					\item Exception handler hijacking: overwrite list of registered exception handlers
					\item Virtual pointer smashing: modifying virtual pointer to point to own virtual function table
				\end{itemize}
			\item Hardware Code Injection
				\begin{itemize}
					\item Partial bitfiles in FPGAs / Trojan cores in ASICs
					\item Adding a malicious core to gather data / do evil shit
				\end{itemize}
			\item Countermeasures
				\begin{itemize}
					\item Additional Return Stack
						\begin{itemize}
							\item Additional hardware return stack (SRAS)
							\item Problems: multi-tasking, interrupts, setjmp / longjmp
							\item Solutions: additional instructions, SmashGuard searches for longjmp returns
						\end{itemize}
					\item Address Obfuscation
						\begin{itemize}
							\item Randomize stack and heap addresses and location of shared libs / static data
							\item XORing function pointers with randomly assigned key
						\end{itemize}
					\item Software Encryption
						\begin{itemize}
							\item Instructions are stored encrypted
							\item During fetch they get decoded (each process has own key)
						\end{itemize}
					\item Safe Languages
						\begin{itemize}
							\item Cyclone: static and dynamic checks, avoidsoverflow and format string
							\item CCured (source-source translator): static + dynamic, need library wrappers
							\item Static analyzers: Splint, PREfix, ITS4 (heuristics and annotations)
							\item Dynamic Code analyzers: Rational Purify, STOBO, FIST (test pot. malicious inputs)
						\end{itemize}
					\item Anomaly Detection
						\begin{itemize}
							\item Compare behavior to profile (defined vs. learned)
							\item Approach: monitor syscalls
						\end{itemize}
					\item Compiler Support
						\begin{itemize}
							\item StackGuard: canary word between vars and return address
							\item ProPolice: also protects registers (SSP)
							\item Stack Shield: redundand return address in data segment
							\item Return Address Defender: copies of return pointers stored in data segment, surrounded by mines
							\item PointGuard: pointers are stored encrypted
							\item XFI: static analysis and inline guards through binary rewriting, dual stacks
							\item Out-of-bound pointers: redirected to out of bounds object
						\end{itemize}
					\item Library Support
						\begin{itemize}
							\item Use of safer functions (strlcpy, SafeStr lib, FormatGuard lib)
							\item Problem modification of code
							\item libsafe and libverify: transparent dynamic link libs
							\item libsafe intercepts vulnerable calls and replaces them
							\item libverify uses binary rewriting to verify stack pointer (also canaries)
							\item ContraPolice: modifies alloc and free of heap with canaries
						\end{itemize}
					\item OS Support
						\begin{itemize}
							\item Marking stack non-executable (NX flag)
							\item Kernel extension PaX and Exec Shield
							\item $W\oplus X$ protection
							\item Drawbacks: functional languages, ROP
						\end{itemize}
					\item Control Flow Checking
						\begin{itemize}
							\item Checking sequences of program counter values
							\item Software Implemented Hardware Fault Tolerance (SIHFT)
							\item Control blocks between basic blocks preventing wrong jumps
							\item Watchdog Processor: program derived from cf-graph or function-graph
							\item Uses signatures (e.g. start address) for each node
							\item Embedded (ESM) vs. autonomous (ASM) Signature Monitoring
							\item ESM: signatures stored between basic blocks and transfered while execution
							\item ASM: signatures stored in watchdog, cfg mapped to control program
						\end{itemize}
					\item ASM approach
						\begin{itemize}
							\item Needed: current pc, next pc, correct jump targets + sources
							\item direct jumps: source + target, indirect: only source, interrupts: only target
							\item Control Flow Method (CF): basic blocks as nodes
							\item CF Instruction Method (CFI): cf instructions as nodes
							\item Components: Memory, CF-Checker, Extensions (modular concept)
							\item Small area overhead, fast error detection, no performance impact
						\end{itemize}
				\end{itemize}

		\end{itemize}

	\section{Invasive physical attacks}
		\begin{itemize}
			\item Compromised security goals
				\begin{itemize}
					\item Availability: damaging, cutting wires
					\item Confidentiality: recover sensitive data / implementation details
					\item Integrity: Manipulation of circuits / data
				\end{itemize}
			\item Attacks need special equipment and time
			\item Depacking
				\begin{itemize}
					\item Opening chip package or removing plastic card
					\item Heating and use of chemicals
				\end{itemize}
			\item Layer Reconstruction
				\begin{itemize}
					\item Creating map of the chip
					\item Using optical microscope to get mosaics of chip surface
					\item Stripping of metal layers with acid
					\item Standard architectures / cells help identifying components
					\item Reading out ROM contents
					\item Constructing a netlist for understanding and finding weaknesses
					\item Layout can be used to clone product
				\end{itemize}
			\item Manual Micro-probing
				\begin{itemize}
					\item Probe shaft thickness about $10\mu m$, tip $< 0.1 \mu m$
					\item Recording values / overwriting signals
					\item Removing the passivation layer with a laser cutter
				\end{itemize}
			\item Advanced Beam Technologies
				\begin{itemize}
					\item Focused Ion Beam
						\begin{itemize}
							\item Vacuum chamber and particle gun (gallium)
							\item Scanning structures down to 5nm
							\item Detecting secondary particles (ions and electrons)
							\item Removing material with higher currents
							\item Gas-assisted etch: up to 12 times deeper
							\item Navigate using laser interferometer stages
							\item Microprobing deeper signal lines by drilling holes and creating pads
						\end{itemize}
					\item Electron Beam Tester
						\begin{itemize}
							\item Scanning Electron Microscope with voltage-contrast function
							\item Energy of secondary electrons corresponds to electric field
							\item Observing signals if clock is below 100 kHz
						\end{itemize}
					\item Infrared Laser
						\begin{itemize}
							\item Scanning with infrared laser from rear (silicon transparent)
							\item Photon current corresponds to internal states of transistors
						\end{itemize}
				\end{itemize}
			\item Key and Memory Reading
				\begin{itemize}
					\item Reading out ROM contents (layer reconstr., EBT)
					\item Reading RAM content by bus probing (micro porbe, EBT)
					\item Replaying memory transactions by overwriting signals
					\item Checking checksums leaks information
					\item Generating linear memory trace by cutting jump / branch signals
					\item Key Retrieval using Test Modes: Re-enable test routines by bridging fuses (probe)
					\item KR using ROM Overwriting
						\begin{itemize}
							\item 
						\end{itemize}
					\item KR using ROM Overwriting
						\begin{itemize}
							\item 
						\end{itemize}
					\item KR using EEPROM overwriting
						\begin{itemize}
							\item 
						\end{itemize}
					\item KR using Gate Destruction
						\begin{itemize}
							\item 
						\end{itemize}
					\item KR using Memory Remanence
						\begin{itemize}
							\item 
						\end{itemize}
					\item KR by Probing Single Bus Bits
						\begin{itemize}
							\item 
						\end{itemize}
				\end{itemize}

		\end{itemize}

	\section{Non invasive logical attacks}
		\begin{itemize}
			\item 
		\end{itemize}

	\section{Non invasive physical attacks}
		\begin{itemize}
			\item 
		\end{itemize}

	\section{Automotive case study}
		\begin{itemize}
			\item 
		\end{itemize}


\end{document}
